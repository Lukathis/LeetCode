Background:In our daily work, we interact with various tools and data, while they are not necessarily easy to use. The tool itself may provide large and full use of the method, but most of us can’t remember or use all of them. On the other hand, the features we often use in a particular scenario require very complex operations and obtain unsatisfactory results. Besides that, there are some modules that are not yet well interactive tools. The above is the original intention of our project, Fincli, is a dedicated and unified platform, specifically for our work scenes, to solve the above problems.现在我们每天的工作中，我们会用到各式各样的工具和数据，但是它们使用起来不一定方便，一来是工具本身可能提供大而全的使用方法，但是大部分我们记不住且用不到，二来是我们在特定场景下经常使用的功能需要非常复杂的操作并且得到的也是很不直观的结果，甚至不提供支持，然后还有一些模块现在还没有很好的交互式的工具，这就是我们项目的初衷，我们的fincli呢，是一个专而统一的平台，专门针对我们的工作场景，解决上面的问题。Then we first look at the fincli in the entire working environment in the topology, fincli will be through different ways to connect with the external platform, send, accept and process the data. For example, we will access jira, alm through the networking protocol, access to the db2 and Sybase easily, obtain log and report through the file system,and these platforms may be in different environments, such as log may be in Dev, QA, uat and Prod1, these are also our fincli going to face. So our aim is that users only need to interact with our fincli, we put all the complex external environment to our fincli to face. Then the blue part is already in use, the red is going to be supported.然后我们先来看一下fincli在整个工作环境中的拓扑图，fincli会通过不同的方式与外部平台进行连接，数据的发送，接受和处理。比如我们会通过网络访问jira，alm，通过数据库的方式访问代表db2和Sybase，通过file system来获取log和report，并且这些平台可能在不同的环境下，比如log就可能在Dev，QA，uat和prod1，这些也同样是我们的fincli要去面对的。所以我们的宗旨就是用户只需要和我们的fincli进行交互，我们把复杂外部环境全部交给我们的fincli去面对。然后这里蓝色的部分是已经在使用了的，红色的是将要支持的。Now we continue to zoom in, look at the overall structure of our fincli, from this picture we can see, fincli modularity especially what is the layer. First of all, the bottom of the core is. The The Many of the fincli's connections to the company's internal platform are built through it, which of course is not what we intern. Up is our fincli internal structure, and our fincli is organized by the plugin way, so we are the bottom of a plugin library, is a plugin developers will use the tool library, up is the plugin layer, Fincli business-related core function logic are in this layer, plugin will have some unified template, or to achieve a unified interface, but there is no coupling between the plugin, that is not only plugin plugin not dependent on the other For example, plugin is no way to take the initiative in their own internal and other plugin communication, if you want to achieve, the practice is to add the message in the plugin library module, which is somewhat similar to the micro-kernel design, there is a practice is passive So that users help you pass, we have a shell in the shell layer of the module, which in fact corresponds to our language to provide users with context-sensitive abstraction, the user can call the results of the variable after the pass to the other plugin. We just also see the shell module, shell to take its intention is a shell, which in addition to the context also contains parser, our language parser, and manager, external interaction and the call to the plugin. Config is a module to load the user profile, the terminal is a more beautiful Linux terminal UI, then through it to the demo, SOAP and these other red are in the plan but not yet completed the module, This module is to send and receive SOAP message, so that users can access through the Web.现在我们继续zoom in，来看一下我们fincli的整体架构，从这张图我们可以看到，看到什么呢，看到fincli的modularity特别是layer是怎样的。首先，最下面的core是。。。fincli的许多与公司内部平台的连接通信都是通过它来建立的，这当然不是我们intern做的。往上就是我们fincli的内部架构了，我们的fincli是由plugin的方式组织的，所以我们最底层是一个plugin的library，就是一个plugin的开发者会用到的工具库，往上就是plugin层，fincli的business相关的核心功能逻辑都在这一层，plugin都会有一些统一的template，或者实现统一的interface，但是plugin之间是没有耦合的，也就是说plugin不仅对其它的plugin没有依赖，举个例子，plugin是没办法主动在自己的内部和其他plugin通信的，如果想要实现，做法就是在plugin library添加消息传递模块，这就有点类似于微内核的设计，还有一种做法就是被动地让用户帮你传递，，我们在shell层有context的模块，这其实对应了我们的语言为用户提供的上下文相关的抽象，用户可以把调用结果存在variable里之后传给其他plugin。我们正好也看到了shell模块，shell取其本意就是个壳，里面除了context还包含了parser，我们语言的解析器，和manager，对外的交互和对plugin的调用。config是加载用户配置文件的一个模块，往上这个terminal是一个比较精美的Linux terminal UI，之后会通过它来进行demo，SOAP 和 这些其他的红色的都是在计划中但是还未完成的模块，这个模块就是收发处理SOAP message，使用户可以通过Web来访问。接下来首先介绍一下我们的dsl和它的compiler部分，就是当我们拥有了很多的plugin，我们不能再像原始的工具一样，各有各的用法而且还是非常不flexible的用法，极端的例子就像是你写了一个工具但是也就几个功能没必要做一个UI，每次用就写个脚本跑一下，这让别人用起来是很痛苦的。所以在0plugin多了以后，设计一个dsl就变得非常有意义了，而且因为它是正对特定的领域的，所以它可以设计的非常接近自然语言，因为支持的领域宽泛后自然语言的二义性就非常难消除了。所以在我们的工作场景中，我们发现最常用的功能就是query，edit，create，view这些，所以我们的语言对他们做了非常灵活的支持，这在之后的demo中可以看到。接下来到了我们核心的plugin模块，如何添加一个新的plugin，首先在我们的core和plugin library里面找到基础的支持，然后你只要实现business相关的逻辑，继承我们的接口，然后别人就可以直接用了，也就是说除了业务相关的处理逻辑外要做的工作几乎为零，因为和用户的交互以及大部分情况下的基础功能，比如你需要访问db2，我们已经为你提供了。这样做带来的好处就是plugin的开发人员不用白手起家，也不需要花时间去做最后的交互。然后介绍一下我们几个主要的plugin，首先是jira的plugin，我们平时可能会用jql来做查询，但是我们有些经常会遇到的场景，比如操作sub task。还有一个就是jira不能导出成已经定义的模板，另外非常麻烦的一件事是jira目前无法和alm交互，据我所知现在都是手动去做的。jira plugin解决的就是上面的问题，他实现了非常flexible的查询和output功能，并且在将来也会支持alm。然后一个非常重要的plugin就是log，我们非常需要一种途径去了解不同环境下report被使用的情况和user的使用记录，我们肯定不希望我们在report123上花费了很大精力，结果QA测的是456，user用的是789。还有一个问题是我们目前没有一个log的分析工具，所以要找某条request都是通过肉眼的方式，所以我们现在log plugin能对report的使用情况做统计分析和灵活的query支持。还有一个正在做的plugin是report automation，当我们要drill down操作时，我们不知道从这个drill down下去能不能得到数据，我们需要一个工具来清除地告诉我们这棵report tree的全貌，方便我们去遍历这个report。所以我们目前在对qs和report的configuration做一个静态分析，并根据db的反馈结果验证我们分析的准确性。这个plugin还能带来一些额外的好处，就是我们能够验证report的正确性，能够看到source entities和他们join的细节，还有其他的一些feature